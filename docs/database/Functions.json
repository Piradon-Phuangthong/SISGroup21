[
    {
        "function_name": "enforce_single_owner_per_omada",
        "arguments": "",
        "return_type": "trigger",
        "full_definition": "CREATE OR REPLACE FUNCTION public.enforce_single_owner_per_omada()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\ndeclare\n  owner_role_id uuid;\n  owners_count int;\nbegin\n  -- find the role_id for 'owner'\n  select id into owner_role_id from public.omada_roles where key = 'owner';\n\n  if (new.role_id = owner_role_id and new.status = 'active') then\n    select count(*) into owners_count\n    from public.omada_members\n    where omada_id = new.omada_id\n      and role_id = owner_role_id\n      and status = 'active'\n      -- exclude current row when updating existing membership\n      and (tg_op <> 'UPDATE' or (omada_id, user_id) <> (old.omada_id, old.user_id));\n\n    if owners_count > 0 then\n      raise exception 'Each omada can have only one active Owner';\n    end if;\n  end if;\n\n  return new;\nend;\n$function$\n"
    },
    {
        "function_name": "generate_unique_username",
        "arguments": "base text",
        "return_type": "text",
        "full_definition": "CREATE OR REPLACE FUNCTION public.generate_unique_username(base text)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\ndeclare\n  clean_base text := lower(regexp_replace(coalesce(base, ''), '[^a-z0-9_]', '_', 'gi'));\n  candidate text;\n  suffix integer := 0;\nbegin\n  if clean_base is null or length(clean_base) = 0 then\n    clean_base := 'user';\n  end if;\n\n  loop\n    candidate := case when suffix = 0 then clean_base else clean_base || '_' || suffix::text end;\n    exit when not exists (select 1 from public.profiles where username = candidate);\n    suffix := suffix + 1;\n  end loop;\n\n  return candidate;\nend;\n$function$\n"
    },
    {
        "function_name": "handle_new_user",
        "arguments": "",
        "return_type": "trigger",
        "full_definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\ndeclare\n  base_username text;\n  generated_username text;\nbegin\n  -- Prefer meta-provided username, else email local-part, else short id\n  base_username := coalesce(new.raw_user_meta_data->>'username', split_part(new.email, '@', 1), left(new.id::text, 8));\n  generated_username := public.generate_unique_username(base_username);\n\n  insert into public.profiles (id, username)\n  values (new.id, generated_username);\n\n  return new;\nend;\n$function$\n"
    },
    {
        "function_name": "handle_new_user_provisioning",
        "arguments": "",
        "return_type": "trigger",
        "full_definition": "CREATE OR REPLACE FUNCTION public.handle_new_user_provisioning()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_username text;\n  v_full_name text;\n  v_given_name text;\n  v_family_name text;\n  v_contact_id uuid;\n  v_existing_contact_id uuid;\n  v_existing_channel_id uuid;\nbegin\n  -- Derive reasonable defaults from auth.users\n  -- raw_user_meta_data can carry optional name fields if you collect them at signup\n  v_full_name  := coalesce((new.raw_user_meta_data->>'full_name'), null);\n  v_given_name := coalesce((new.raw_user_meta_data->>'given_name'), null);\n  v_family_name:= coalesce((new.raw_user_meta_data->>'family_name'), null);\n\n  -- Create a unique-ish username: local-part + \"_\" + first 6 chars of UUID\n  v_username := split_part(new.email, '@', 1) || '_' || substr(new.id::text, 1, 6);\n\n  -- 1a) Ensure profile exists (profiles.id == auth.users.id)\n  insert into public.profiles (id, username)\n  values (new.id, v_username)\n  on conflict (id) do nothing;\n\n  -- 2) Ensure a self-contact exists for this user\n  -- Prefer to reuse a contact with the same owner and primary_email=new.email if present;\n  -- otherwise pick the earliest self-contact, otherwise create a new one.\n  select c.id\n  into v_existing_contact_id\n  from public.contacts c\n  where c.owner_id = new.id\n    and c.primary_email = new.email\n  limit 1;\n\n  if v_existing_contact_id is null then\n    -- If not found by primary_email, try \"any\" self contact (old installs may not have primary_email set)\n    select c.id\n    into v_existing_contact_id\n    from public.contacts c\n    where c.owner_id = new.id\n    order by c.created_at asc\n    limit 1;\n  end if;\n\n  if v_existing_contact_id is null then\n    -- Create a fresh contact representing the user themself\n    insert into public.contacts (\n      owner_id,\n      full_name,\n      given_name,\n      family_name,\n      primary_email,\n      is_deleted\n    )\n    values (\n      new.id,\n      v_full_name,\n      v_given_name,\n      v_family_name,\n      new.email,\n      false\n    )\n    returning id into v_contact_id;\n  else\n    v_contact_id := v_existing_contact_id;\n\n    -- If the reused contact doesn't have primary_email, set it now\n    update public.contacts\n    set primary_email = coalesce(primary_email, new.email),\n        updated_at = now()\n    where id = v_contact_id\n      and primary_email is null;\n  end if;\n\n  -- 3) Ensure an email channel exists for this contact pointing to the signup email\n  select cc.id\n  into v_existing_channel_id\n  from public.contact_channels cc\n  where cc.owner_id = new.id\n    and cc.contact_id = v_contact_id\n    and cc.kind = 'email'\n    and cc.value = new.email\n  limit 1;\n\n  if v_existing_channel_id is null then\n    insert into public.contact_channels (\n      owner_id,\n      contact_id,\n      kind,\n      label,\n      value,\n      url,\n      extra,\n      is_primary\n    )\n    values (\n      new.id,\n      v_contact_id,\n      'email',\n      'Primary',\n      new.email,\n      null,\n      '{}'::jsonb,\n      true\n    );\n  else\n    -- Make sure it's primary if it already existed\n    update public.contact_channels\n    set is_primary = true,\n        updated_at = now()\n    where id = v_existing_channel_id;\n  end if;\n\n  return new;\nend;\n$function$\n"
    },
    {
        "function_name": "handle_user_email_changed",
        "arguments": "",
        "return_type": "trigger",
        "full_definition": "CREATE OR REPLACE FUNCTION public.handle_user_email_changed()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_contact_id uuid;\nbegin\n  -- Only act when email actually changes\n  if coalesce(old.email, '') = coalesce(new.email, '') then\n    return new;\n  end if;\n\n  -- Pick a canonical self-contact (earliest for this owner)\n  select c.id\n  into v_contact_id\n  from public.contacts c\n  where c.owner_id = new.id\n  order by c.created_at asc\n  limit 1;\n\n  if v_contact_id is not null then\n    -- Update the contactâ€™s primary_email to the new one\n    update public.contacts\n    set primary_email = new.email,\n        updated_at = now()\n    where id = v_contact_id;\n\n    -- Demote any previous primary email channel with the old email\n    update public.contact_channels\n    set is_primary = false,\n        updated_at = now()\n    where owner_id = new.id\n      and contact_id = v_contact_id\n      and kind = 'email'\n      and value = old.email;\n\n    -- Upsert a primary channel for the new email\n    insert into public.contact_channels (owner_id, contact_id, kind, label, value, url, extra, is_primary)\n    values (new.id, v_contact_id, 'email', 'Primary', new.email, null, '{}'::jsonb, true)\n    on conflict do nothing;\n\n    update public.contact_channels\n    set is_primary = true,\n        updated_at = now()\n    where owner_id = new.id\n      and contact_id = v_contact_id\n      and kind = 'email'\n      and value = new.email;\n  end if;\n\n  return new;\nend;\n$function$\n"
    },
    {
        "function_name": "handle_user_signup",
        "arguments": "",
        "return_type": "trigger",
        "full_definition": "CREATE OR REPLACE FUNCTION public.handle_user_signup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_full_name    text := coalesce(new.raw_user_meta_data->>'full_name',  null);\n  v_given_name   text := coalesce(new.raw_user_meta_data->>'given_name', null);\n  v_family_name  text := coalesce(new.raw_user_meta_data->>'family_name', null);\n\n  v_base_username text := coalesce(\n    new.raw_user_meta_data->>'username',\n    nullif(split_part(new.email, '@', 1), ''),\n    left(new.id::text, 8)\n  );\n  v_username text := public.generate_unique_username(v_base_username);\n\n  v_contact_id uuid;\n  v_existing_contact_id uuid;\n  v_existing_channel_id uuid;\nbegin\n  -- (1) Ensure profile exists with a non-null, unique username (idempotent)\n  insert into public.profiles (id, username)\n  values (new.id, v_username)\n  on conflict (id) do update\n    set username = excluded.username;\n\n  -- (2) Ensure a self-contact exists for this user (idempotent)\n  select c.id\n    into v_existing_contact_id\n  from public.contacts c\n  where c.owner_id = new.id\n    and c.primary_email is not distinct from new.email\n  limit 1;\n\n  if v_existing_contact_id is null then\n    select c.id\n      into v_existing_contact_id\n    from public.contacts c\n    where c.owner_id = new.id\n    order by c.created_at asc\n    limit 1;\n  end if;\n\n  if v_existing_contact_id is null then\n    insert into public.contacts (\n      owner_id, full_name, given_name, family_name, primary_email, is_deleted\n    ) values (\n      new.id, v_full_name, v_given_name, v_family_name, new.email, false\n    )\n    returning id into v_contact_id;\n  else\n    v_contact_id := v_existing_contact_id;\n\n    update public.contacts\n    set primary_email = coalesce(primary_email, new.email),\n        updated_at    = now()\n    where id = v_contact_id\n      and primary_email is null;\n  end if;\n\n  -- (3) Ensure a primary email channel exists pointing to signup email (idempotent)\n  if new.email is not null then\n    select cc.id\n      into v_existing_channel_id\n    from public.contact_channels cc\n    where cc.owner_id  = new.id\n      and cc.contact_id = v_contact_id\n      and cc.kind       = 'email'\n      and cc.value      = new.email\n    limit 1;\n\n    if v_existing_channel_id is null then\n      insert into public.contact_channels (\n        owner_id, contact_id, kind, label, value, url, extra, is_primary\n      ) values (\n        new.id, v_contact_id, 'email', 'Primary', new.email, null, '{}'::jsonb, true\n      );\n    else\n      update public.contact_channels\n      set is_primary = true,\n          updated_at = now()\n      where id = v_existing_channel_id;\n    end if;\n  end if;\n\n  return new;\nend;\n$function$\n"
    },
    {
        "function_name": "set_updated_at",
        "arguments": "",
        "return_type": "trigger",
        "full_definition": "CREATE OR REPLACE FUNCTION public.set_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n  new.updated_at := now();\n  return new;\nend;\n$function$\n"
    },
    {
        "function_name": "sync_omada_owner_id",
        "arguments": "",
        "return_type": "trigger",
        "full_definition": "CREATE OR REPLACE FUNCTION public.sync_omada_owner_id()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\ndeclare\n  owner_role_id uuid;\nbegin\n  select id into owner_role_id from public.omada_roles where key = 'owner';\n\n  if (new.role_id = owner_role_id and new.status = 'active') then\n    update public.omadas set owner_id = new.user_id, updated_at = now()\n    where id = new.omada_id;\n  end if;\n\n  return new;\nend;\n$function$\n"
    }
]